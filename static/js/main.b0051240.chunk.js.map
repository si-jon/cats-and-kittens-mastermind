{"version":3,"sources":["voice.ts","dmReprompt.ts","grammars/grammar.ts","dmHowToPlay.ts","dmMastermind.ts","dmMain.ts","dmRasaQuery.ts","index.tsx"],"names":["say","text","send","_context","type","value","listen","cancel","actions","startRepromptTimer","delay","id","cancelRepromptTimer","resetRepromptCount","assign","repromptCount","context","reprompt","repromptMessage","state","initial","states","repromptCounter","entry","always","cond","target","on","ENDSPEECH","exit","done","digitGrammar","digit","yes_no_grammar","dmHowToPlayMachine","pre","mid","cat","kitten","sendQuery","recResult","generateDigits","digits","i","push","Math","floor","random","splitDigitString","inputStr","preSplit","split","forEach","element","idx","arr","undefined","pruneStr","join","replace","Array","from","getCount","length","isValidInput","splitStr","parsed","Number","isNaN","isDigits","convertToDigits","addToHistory","guess","catCount","kittenCount","guessHistory","addCatsAndKittensHistory","cats","kittens","soughtDigits","guessedDigits","digitsResponse","availablekittens","guessesLeft","NaN","j","getCatsAndKittensMessage","catStr","kittenStr","getWinMessage","guessCount","saveDigits","dmMastermindMachine","catsnkittens","welcome","play","prompt","ask","onDone","result","tooMany","tooFew","invalid","TIMER","RECOGNISED","d","allCorrect","finished","gamehist","history","playprompt","common","help","howToPlayInGame","nomatch","pending","RESPONSE","event","RESPONSE_ERROR","quitgame","dmMainMachine","init","CLICK","intro","quit","howToPlay","options","dmMastermind","error","dmRasaQueryMachine","QUERY","query","invoke","src","fetch","Request","proxyurl","method","headers","body","then","data","json","intent","name","console","log","onError","inspect","url","iframe","machine","Machine","nluData","ttsAgenda","dm","dmRasaQuery","asrtts","idle","LISTEN","SPEAK","recognising","ASRRESULT","STOP_LISTEN","progress","match","speaking","recLogResult","test","logIntent","ReactiveButton","props","matches","className","style","animation","GuessList","ghli","map","guessData","index","WinMessage","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","ttsStart","effect","ttsCancel","current","onClick","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.b0051240.chunk.js","sourcesContent":["import { send, Action } from \"xstate\";\n\nexport function say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: 'SPEAK', value: text }))\n}\n\nexport function listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n","import { MachineConfig, send, Action, assign, actions } from \"xstate\";\nimport { say } from \"./voice\";\n\nconst { cancel } = actions;\n\nexport const startRepromptTimer: Action<SDSContext, SDSEvent> = send('TIMER', { delay: 30000, id: 'repromptTimer' })\nexport const cancelRepromptTimer: Action<SDSContext, SDSEvent> = cancel('repromptTimer')\nexport const resetRepromptCount: Action<SDSContext, SDSEvent> = assign({ repromptCount: context => 0 })\n\nexport function reprompt(repromptMessage: string, state: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'reprompt',\n        states: {\n            repromptCounter: {\n                entry: [\n                    send('STOP_LISTEN'),\n                    assign({ repromptCount: context => context.repromptCount + 1 }),\n                ],\n                always: [\n                    {\n                        cond: (context) => context.repromptCount > 5,\n                        target: 'done'\n                    },\n                    {\n                        target: 'reprompt'\n                    }\n                ]\n            },\n            reprompt: {\n                entry: say(repromptMessage),\n                on: {\n                    ENDSPEECH: state,\n                },\n                exit: startRepromptTimer\n            },\n            done: {\n                type: 'final'\n            }\n        },\n    })\n}","export const digitGrammar: { [index: string]: { digit?: string } } = {\n    \"zero\": { digit: '0' },\n    \"one\": { digit: '1' },\n    \"two\": { digit: '2' },\n    \"three\": { digit: '3' },\n    \"four\": { digit: '4' },\n    \"for\": { digit: '4' },\n    \"five\": { digit: '5' },\n    \"six\": { digit: '6' },\n    \"seven\": { digit: '7' },\n    \"eight\": { digit: '8' },\n    \"nine\": { digit: '9' },\n}\n\nexport const yes_no_grammar: { [index: string]: {} } = {\n    \"yes\": true,\n    \"you bet\": true,\n    \"yeah\": true,\n    \"no\": false,\n    \"no way\": false,\n    \"nope\": false,\n}","import { MachineConfig } from \"xstate\";\nimport { say } from \"./voice\";\n\nconst preText = \"Cats and kittens is a version of the game Mastermind. \\\n    Your task is to figure out my four digit code with help of my hints.\"\n\nconst mitText = \"You guess which four digits, 0-9, are in my code, and I'll give you a hint of each guess.\\\n        The hints are the number of cats and kittens!\"\n\nconst catText = \"A cat indicates one of the numbers in your guess are in the correct spot.\"\nconst kittenText = \"A kitten indicates one of the numbers in your guess are included in the code, but in the wrong spot.\"\n\nexport const dmHowToPlayMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'pre',\n    states: {\n        pre: {\n            entry: say(preText),\n            on: { ENDSPEECH: 'mid' }\n        },\n        mid: {\n            entry: say(mitText),\n            on: { ENDSPEECH: 'cat' }\n        },\n        cat: {\n            entry: say(catText),\n            on: { ENDSPEECH: 'kitten' }\n        },\n        kitten: {\n            entry: say(kittenText),\n            on: { ENDSPEECH: 'done' }\n        },\n        done: {\n            type: 'final',\n        },\n    }\n})\n","import { MachineConfig, send, Action, assign, actions } from \"xstate\";\nimport { say, listen } from \"./voice\";\nimport { reprompt, startRepromptTimer, cancelRepromptTimer, resetRepromptCount } from \"./dmReprompt\";\nimport { digitGrammar, yes_no_grammar } from \"./grammars/grammar\"\nimport { dmHowToPlayMachine } from \"./dmHowToPlay\";\n\nconst sendQuery: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"QUERY\", value: context.recResult\n}))\n\nfunction generateDigits(): Array<number> {\n    let digits: Array<number> = [];\n\n    for (var i = 0; i < 4; i++) {\n        digits.push(Math.floor(Math.random() * 10));\n    }\n    return digits;\n}\n\nfunction splitDigitString(inputStr: string): Array<string> {\n    const preSplit = inputStr.split(' ');\n    preSplit.forEach((element, idx, arr) => {\n        if (digitGrammar[element] != undefined && 'digit' in digitGrammar[element]) {\n            arr[idx] = digitGrammar[element].digit || '';\n        }\n    });\n    const joinStr = preSplit.join('');\n    const pruneStr = joinStr.replace(/[^0-9]/g, '');\n    const splitStr = Array.from(pruneStr);\n    return splitStr\n}\n\nfunction getCount(inputStr: string): number {\n    return splitDigitString(inputStr).length;\n}\n\nfunction isDigits(inputStr: string): boolean {\n    const splitStr = splitDigitString(inputStr);\n    for (let i in splitStr) {\n        const parsed = Number(splitStr[i])\n        if (isNaN(parsed)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isValidInput(inputStr: string): boolean {\n    return (getCount(inputStr) == 4) && isDigits(inputStr);\n}\n\nfunction convertToDigits(inputStr: string): Array<number> {\n    const splitStr = splitDigitString(inputStr);\n    var digits: Array<number> = [];\n    for (let i in splitStr) {\n        let parsed = Number(splitStr[i]);\n        digits.push(parsed);\n    }\n    return digits;\n}\n\nfunction allCorrect(soughtDigits: Array<number>, guessedDigits: string): boolean {\n    const d = convertToDigits(guessedDigits);\n    for (let i = 0; i < 4; i++) {\n        if (d[i] != soughtDigits[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction addToHistory(context: SDSContext, guess: string, catCount: number, kittenCount: number) {\n    context.guessHistory.push({\n        guess: guess,\n        catCount: catCount,\n        kittenCount: kittenCount\n    });\n}\nfunction addCatsAndKittensHistory(context: SDSContext) {\n    let cats = 0;\n    let kittens = 0;\n    let soughtDigits = [...context.digits]\n    let guessedDigits = [...context.digitsResponse]\n    let availablekittens = [...soughtDigits];\n    let guessesLeft = guessedDigits;\n    for (let i = 0; i < 4; i++) {\n        if (guessedDigits[i] == soughtDigits[i]) {\n            cats += 1;\n            availablekittens[i] = NaN;\n            guessesLeft[i] = NaN;\n        }\n    }\n    for (let i = 0; i < 4; i++) {\n        if (!isNaN(guessesLeft[i])) {\n            for (let j = 0; j < 4; j++) {\n                if (!isNaN(availablekittens[j]) && (guessesLeft[i] == availablekittens[j])) {\n                    kittens += 1;\n                    guessesLeft[i] = NaN;\n                    availablekittens[j] = NaN;\n                }\n            }\n        }\n    }\n    addToHistory(context, context.digitsResponse.join(\"\"), cats, kittens);\n}\n\nfunction getCatsAndKittensMessage(context: SDSContext): string {\n    addCatsAndKittensHistory(context)\n    const idx = context.guessHistory.length - 1;\n    let cats = 0;\n    let kittens = 0;\n    if (idx >= 0) {\n        cats = context.guessHistory[idx].catCount;\n        kittens = context.guessHistory[idx].kittenCount;\n    }\n    const catStr = (cats == 1) ? \"cat\" : \"cats\";\n    const kittenStr = (kittens == 1) ? \"kitten\" : \"kittens\";\n    return `${cats} ${catStr}, ${kittens} ${kittenStr}`;\n}\n\nfunction getWinMessage(context: SDSContext): string {\n    addCatsAndKittensHistory(context);\n    const guessCount = context.guessHistory.length\n    return `Meow meow meow meow! Purrfect! You got it in ${guessCount} tries!`;\n}\n\n\nconst saveDigits: Action<SDSContext, SDSEvent> = assign((context: SDSContext) => {\n    return { digitsResponse: convertToDigits(context.recResult) }\n})\n\nexport const dmMastermindMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'catsnkittens',\n    entry: [\n        resetRepromptCount,\n        assign({ guessHistory: context => [] }),\n    ],\n    states: {\n        catsnkittens: {\n            id: 'catsnkittens',\n            initial: 'welcome',\n            states: {\n                welcome: {\n                    entry: [\n                        assign(context => { return { digits: generateDigits() } }),\n                        say(\"Let's play cats and kittens!\"),\n                    ],\n                    on: {\n                        ENDSPEECH: 'play',\n                    }\n                },\n                play: {\n                    id: 'play',\n                    initial: 'prompt',\n                    states: {\n                        prompt: {\n                            entry: say(\"Give me four digits!\"),\n                            on: {\n                                ENDSPEECH: 'ask'\n                            },\n                            exit: startRepromptTimer\n                        },\n                        ask: {\n                            entry: listen(),\n                            exit: cancelRepromptTimer\n                        },\n                        reprompt: {\n                            ...reprompt(\"You can ask me for help if you need to.\", '#play.ask'),\n                            onDone: '#done'\n                        },\n                        result: {\n                            entry: [\n                                send((context) => ({\n                                    type: \"SPEAK\",\n                                    value: getCatsAndKittensMessage(context)\n                                }))],\n                            on: {\n                                ENDSPEECH: 'prompt'\n                            }\n                        },\n                        tooMany: {\n                            entry: [\n                                (context) => (addToHistory(context, context.digitsResponse.join(\"\"), 0, 0)),\n                                say(\"That's too many digits\"),\n                            ],\n                            on: {\n                                ENDSPEECH: 'prompt',\n                            }\n                        },\n                        tooFew: {\n                            entry: [\n                                (context) => (addToHistory(context, context.digitsResponse.join(\"\"), 0, 0)),\n                                say(\"That's too few digits\"),\n                            ],\n                            on: {\n                                ENDSPEECH: 'prompt',\n                            }\n                        },\n                        invalid: {\n                            entry: [\n                                (context) => (addToHistory(context, \"<not digits>\", 0, 0)),\n                                say(\"That's not four digits\"),\n                            ],\n                            on: {\n                                ENDSPEECH: 'prompt',\n                            }\n                        }\n                    },\n                    on: {\n                        TIMER: '.reprompt.repromptCounter',\n                        RECOGNISED: [{\n                            cond: (context) => context.recResult === 'help',\n                            target: '#helpgame'\n                        },\n                        {\n                            cond: (context) => context.recResult === 'quit',\n                            target: '#quitgame'\n                        },\n                        {\n                            cond: (context) => allCorrect(context.digits, context.recResult),\n                            actions: saveDigits,\n                            target: 'finished'\n                        },\n                        {\n                            cond: (context) => isValidInput(context.recResult),\n                            actions: saveDigits,\n                            target: '.result'\n                        },\n                        {\n                            cond: (context) => getCount(context.recResult) > 4,\n                            actions: saveDigits,\n                            target: '.tooMany'\n                        },\n                        {\n                            cond: (context) => getCount(context.recResult) < 4 && getCount(context.recResult) > 0,\n                            actions: saveDigits,\n                            target: '.tooFew'\n                        },\n                        {\n                            target: '.invalid'\n                        }\n                        ]\n                    }\n                },\n                finished: {\n                    entry: [\n                        send((context) => ({\n                            type: \"SPEAK\",\n                            value: getWinMessage(context)\n                        })),\n                    ],\n                    on: {\n                        ENDSPEECH: '#playprompt'\n                    }\n                },\n                gamehist: {\n                    type: 'history',\n                    history: 'shallow'\n                },\n            },\n        },\n        playprompt: {\n            id: 'playprompt',\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Do you want to play again?\"),\n                    on: {\n                        ENDSPEECH: 'ask'\n                    },\n                    exit: startRepromptTimer\n                },\n                ask: {\n                    entry: listen(),\n                    exit: cancelRepromptTimer\n                },\n                reprompt: {\n                    ...reprompt(\"Play again?\", '#playprompt.ask'),\n                    onDone: '#done'\n                },\n            },\n            on: {\n                TIMER: '.reprompt.repromptCounter',\n                RECOGNISED: [{\n                    cond: (context) => yes_no_grammar[context.recResult] === true,\n                    actions: [\n                        assign({ guessHistory: context => [] }),\n                    ],\n                    target: 'catsnkittens'\n                },\n                {\n                    cond: (context) => yes_no_grammar[context.recResult] === false,\n                    target: 'done'\n                },\n                {\n                    target: '.prompt'\n                }\n                ]\n            }\n        },\n        common: {\n            id: 'common',\n            states: {\n                help: {\n                    id: 'helpgame',\n                    initial: 'prompt',\n                    states: {\n                        prompt: {\n                            entry: say(\"Do you want to know the rules of the game, quit the game, or continue playing?\"),\n                            on: { ENDSPEECH: 'ask' },\n                            exit: startRepromptTimer\n                        },\n                        ask: {\n                            entry: listen(),\n                            exit: cancelRepromptTimer\n                        },\n                        howToPlayInGame: {\n                            ...dmHowToPlayMachine,\n                            onDone: {\n                                target: '#catsnkittens.gamehist'\n                            }\n                        },\n                        reprompt: {\n                            ...reprompt(\"Do you want to know the rules of the game, quit the game, or continue playing?\", '#helpgame.ask'),\n                            onDone: '#done'\n                        },\n                        nomatch: {\n                            entry: say(\"Sorry, I don't know how to do this.\"),\n                            on: { ENDSPEECH: 'prompt' }\n                        },\n                        pending: {\n                            id: 'pending',\n                            on: {\n                                RESPONSE: [\n                                    {\n                                        cond: (context, event) => event.value === \"continue\",\n                                        target: '#catsnkittens.gamehist',\n                                    },\n                                    {\n                                        cond: (context, event) => event.value === \"quit\",\n                                        target: '#quitgame'\n                                    },\n                                    {\n                                        cond: (context, event) => event.value === \"how_to_play\",\n                                        target: 'howToPlayInGame'\n                                    },\n                                    { target: 'nomatch' }\n                                ],\n                                RESPONSE_ERROR: {\n                                    target: '#error',\n                                }\n                            }\n                        },\n                    },\n                    on: {\n                        TIMER: '.reprompt.repromptCounter',\n                        RECOGNISED: {\n                            actions: sendQuery,\n                            target: '.pending',\n                        }\n                    },\n                },\n                quitgame: {\n                    id: 'quitgame',\n                    initial: 'prompt',\n                    states: {\n                        prompt: {\n                            entry: say(\"Are you sure you want to quit?\"),\n                            on: {\n                                ENDSPEECH: 'ask'\n                            },\n                            exit: startRepromptTimer\n                        },\n                        ask: {\n                            entry: listen(),\n                            exit: cancelRepromptTimer\n                        },\n                        reprompt: {\n                            ...reprompt(\"Do you want to exit the game?\", '#quitgame.ask'),\n                            onDone: '#done'\n                        },\n                    },\n                    on: {\n                        TIMER: '.reprompt.repromptCounter',\n                        RECOGNISED: [{\n                            cond: (context) => yes_no_grammar[context.recResult] === true,\n                            target: '#done'\n                        },\n                        {\n                            cond: (context) => yes_no_grammar[context.recResult] === false,\n                            target: '#catsnkittens.gamehist',\n                        },\n                        {\n                            target: '.prompt'\n                        }\n                        ]\n                    }\n                }\n            },\n        },\n        done: {\n            id: 'done',\n            entry: say(\"Bye bye!\"),\n            type: 'final',\n        },\n    },\n})\n","import { MachineConfig, send, Action, assign } from \"xstate\";\nimport { dmMastermindMachine } from \"./dmMastermind\";\nimport { dmHowToPlayMachine } from \"./dmHowToPlay\";\nimport { reprompt, startRepromptTimer, cancelRepromptTimer, resetRepromptCount } from \"./dmReprompt\";\nimport { say, listen} from \"./voice\";\n\nconst sendQuery: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"QUERY\", value: context.recResult\n}))\n\nconst yes_no_grammar: { [index: string]: {} } = {\n    \"yes\": true,\n    \"you bet\": true,\n    \"yeah\": true,\n    \"no\": false,\n    \"no way\": false,\n    \"nope\": false,\n}\n\nexport const dmMainMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    id: 'main',\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Welcome to cats and kittens!\"),\n                    on: { ENDSPEECH: '#intro' },\n                },\n            }\n        },\n\t    intro: {\n            id: 'intro',\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Let's play! Or I can give you some options on what to do!\"),\n                    on: { ENDSPEECH: 'ask' },\n                    exit: startRepromptTimer\n                },\n                ask: {\n                    entry: listen(),\n                    exit: cancelRepromptTimer\n                },\n                reprompt: {\n                    ...reprompt(\"I can give you some options on what to do, if you need to!\", '#intro.ask'),\n                    onDone: '#done'\n                },\n                nomatch: {\n                    entry: say(\"Sorry, I don't know how to do this.\"),\n                    on: { ENDSPEECH: 'prompt' }\n                },\n                pending: {\n                    id: 'pending',\n                    on: {\n                        RESPONSE: [\n                            {\n                                cond: (context, event) => event.value === \"play_game\",\n                                target: '#dmMastermind'\n                            },\n                            {\n                                cond: (context, event) => event.value === \"quit\",\n                                target: '#quit'\n                            },\n                            {\n                                cond: (context, event) => event.value === \"how_to_play\",\n                                target: '#howToPlay'\n                            },\n                            {\n                                cond: (context, event) => event.value === \"options\",\n                                target: '#options'\n                            },\n                            {\n                                cond: (context, event) => event.value === \"help\",\n                                target: '#help'\n                            },\n                            { target: 'nomatch' }\n                        ],\n                        RESPONSE_ERROR: {\n                            target: '#error',\n                        }\n                    }\n                },\n            },\n\t        on: {\n                TIMER: '.reprompt.repromptCounter',\n\t    \t    RECOGNISED: {\n\t    \t        actions: sendQuery,\n\t    \t        target: '.pending',\n                }\n            },\n\t    },\n        quit: {\n            id: 'quit',\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Are you sure you want to quit?\"),\n                    on: { ENDSPEECH: 'ask' },\n                    exit: startRepromptTimer\n                },\n                ask: {\n                    id: 'ask',\n                    entry: listen(),\n                    exit: cancelRepromptTimer\n                },\n                reprompt: {\n                    ...reprompt(\"Do you want to quit?\", '#quit.ask'),\n                    onDone: '#done'\n                },\n                nomatch: {\n                    entry: say(\"Sorry, I didn't catch that.\"),\n                    on: { ENDSPEECH: 'prompt' }\n                },\n                pending: {\n                    id: 'pending',\n                    on: {\n                        RESPONSE: [\n                            {\n                                cond: (context, event) => event.value === \"affirm\",\n                                target: '#done'\n                            },\n                            {\n                                cond: (context, event) => event.value === \"deny\",\n                                target: '#intro'\n                            },\n                            { target: 'nomatch' }\n                        ],\n                        RESPONSE_ERROR: {\n                            target: '#error',\n                        }\n                    }\n                },\n            },\n\t        on: {\n                TIMER: '.reprompt.repromptCounter',\n\t    \t    RECOGNISED: {\n\t    \t        actions: sendQuery,\n\t    \t        target: '.pending',\n                }\n            },\n        },\n        howToPlay: {\n            id: 'howToPlay',\n            ...dmHowToPlayMachine,\n            onDone: {\n                target: 'intro'\n            }\n        },\n        options: {\n            id: 'options',\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"These are your options. Play the game. Ask for the rules. Or exit the game.\"),\n                    on: { ENDSPEECH: '#intro' },\n                },\n            },\n        },\n        help: {\n            id: 'help',\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"If you don't know what to do, you can ask for options.\"),\n                    on: { ENDSPEECH: '#intro' },\n                },\n            },\n        },\n        dmMastermind: {\n            id: 'dmMastermind',\n            ...dmMastermindMachine,\n            onDone: {\n                target: 'init' \n            }\n        },\n        error: {\n            id: 'error',\n            entry: say(\"Sorry, something went wrong. Maybe try again later?\"),\n            on: { ENDSPEECH: 'done' }\n        },\n        done: {\n            id: 'done',\n            entry: say(\"Bye bye!\"),\n            type: 'final',\n        },\n    },\n    onDone: {\n        target: '.init'\n    }\n})","import { MachineConfig, send, assign, Action } from \"xstate\";\n\nconst proxyurl = 'https://cors-anywhere.herokuapp.com/';\nconst rasaurl = 'https://cnk-mastermind-rasa-server.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'https://github.com/si-jon/cats-and-kittens-mastermind' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    })).then(data => data.json());\n\nexport const dmRasaQueryMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                QUERY: {\n                    actions: assign((context, event) => { return { query: event.value } }),\n                    target:'query'\n                }\n            }\n        },\n\t    query: {\n\t        invoke: {\n                src: (context, event) => nluRequest(context.query),\n                onDone: {\n                    target: 'init',\n                    actions: [\n                        send((context, event) => ({ type: \"RESPONSE\", value: event.data.intent.name })),\n                        (context:SDSContext, event:any) => console.log(event.data)\n                        ]\n                },\n\t    \t    onError: {\n                    target: 'init',\n\t    \t        actions: [\n                        send((context, event) => ({ type: \"RESPONSE_ERROR\", value: event.data })),\n                        (context:SDSContext, event:any) => console.log(event.data)\n                    ]\n                }\n            }\n\t    }\n    }\n})\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, send, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMainMachine } from \"./dmMain\";\nimport { dmRasaQueryMachine } from \"./dmRasaQuery\";\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\nconst initContext = {\n    recResult: \"\",\n    nluData: \"\",\n    ttsAgenda: \"\",\n    query: \"\",\n    digits: [],\n    digitsResponse: [],\n    guessHistory: [],\n    repromptCount: 0,\n}\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    context: initContext,\n    states: {\n        dm: {\n            ...dmMainMachine\n        },\n        dmRasaQuery: {\n            ...dmRasaQueryMachine,\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n                    initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        STOP_LISTEN: 'idle'\n                    },\n                    states: {\n                        progress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        case props.state.matches({ dmRasaQuery: 'query' }):\n            console.log('Waiting for rasa result')\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 60s linear\" }} {...props}>\n                    Waiting...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nconst GuessList = (props: Props): JSX.Element => {\n    const history = props.state.context.guessHistory;\n    const ghli = history.map((guessData, index) => {\n        const guess = guessData.guess;\n        const catCount = guessData.catCount;\n        const kittenCount = guessData.kittenCount;\n        return (\n            <li key={index}>\n                <div className=\"guess\">{guess}</div><div className=\"hint\">&#128049;: {catCount} &#128008;: {kittenCount}</div>\n            </li>\n        );\n    });\n    return (\n        <ol className=\"guessList\">{ghli}</ol>\n    );\n}\n\nconst WinMessage = (props: Props): JSX.Element => {\n    const history = props.state.context.guessHistory;\n    const idx = history.length - 1;\n    if (idx >= 0 && history[idx].catCount === 4) {\n        return (\n            <div className=\"winMessage\">&#128568; &#128568; &#128568; &#128568;\n                Purrrrfect!\n            </div>\n        );\n    }\n    return (\n        <div></div>\n    );\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive speech input.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n        }\n    });\n\n    return (\n        <div className=\"background\">\n            <div className=\"Game\">\n                <h1>&#128049; Cats &amp; Kittens! &#128008;</h1>\n                <ReactiveButton state={current} onClick={() => send('CLICK')} />\n                <div id=\"lined\">\n                    <div id=\"content\">\n                        <GuessList state={current} />\n                        <WinMessage state={current} />\n                    </div>\n                </div>\n            </div>\n        </div>\n    )\n};\n\nReactDOM.render(\n    <App />,\n    document.getElementById(\"root\"));\n"],"sourceRoot":""}